<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Earth — no OrbitControls</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { 
	height:100%;
	margin:0;
	background:#000;
	font-family:system-ui; 
	overflow:hidden;
	}
	
    #container {
	width:100%; 
	height:100vh;
	position:relative;
	}
	
    canvas { 
	display:block;
	width:100%;
	height:100%; 
	}
	
    .ui {
      position:absolute; 
	  right:16px; 
	  top:16px;
	  z-index:10;
      display:flex;
	  flex-direction:column; 
	  gap:8px;
    }
    .ui button {
      background: rgba(255,255,255,0.08);
      color:#fff; 
	  border:1px solid rgba(255,255,255,0.12);
      padding:8px 10px;
	  border-radius:6px;
	  cursor:pointer;
      backdrop-filter: blur(4px);
    }
    .credits {
      position:absolute;
	  left:12px;
	  bottom:12px; 
	  color:#ddd;
      font-size:13px;
	  background: rgba(0,0,0,0.35);
	  padding:6px 8px;
	  border-radius:6px;
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <div class="ui" aria-hidden="true">
    <button id="leftBtn">◀ Left</button>
    <button id="rightBtn">Right ▶</button>
    <button id="upBtn">▲ Up</button>
    <button id="downBtn">Down ▼</button>
    <button id="zoomInBtn">＋ Zoom In</button>
    <button id="zoomOutBtn">－ Zoom Out</button>
    <button id="autoRotateBtn">Toggle Auto Rotate</button>
    <button id="resetBtn">Reset</button>
  </div>

  <div class="credits">Drag to rotate • Pinch/scroll to zoom • Touch supported</div>

  <!-- Only Three.js (no OrbitControls) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
    const container = document.getElementById('container');

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    container.appendChild(renderer.domElement);

    // Scene + Camera
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0008);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000);
    let cameraDistance = 6;
    const minDistance = 2.2;
    const maxDistance = 12;
    camera.position.set(0, 0, cameraDistance);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.45));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(5, 3, 5);
    scene.add(dir);

    // Textures
    const loader = new THREE.TextureLoader();
    const earthMap = loader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');
    const cloudsMap = loader.load('https://threejs.org/examples/textures/planets/earth_clouds_1024.png');

    // Earth group
    const earthGroup = new THREE.Group();
    scene.add(earthGroup);

    const RADIUS = 1.8;
    const earthGeo = new THREE.SphereGeometry(RADIUS, 64, 64);
    const earthMat = new THREE.MeshPhongMaterial({ map: earthMap });
    const earthMesh = new THREE.Mesh(earthGeo, earthMat);
    earthGroup.add(earthMesh);

    const cloudGeo = new THREE.SphereGeometry(RADIUS + 0.02, 64, 64);
    const cloudMat = new THREE.MeshLambertMaterial({ map: cloudsMap, transparent: true, opacity: 0.9, depthWrite: false });
    const cloudMesh = new THREE.Mesh(cloudGeo, cloudMat);
    earthGroup.add(cloudMesh);

    // Stars background
    (function createStars(){
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 5000;
      const positions = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
        const i3 = i * 3;
        const r = 100 + Math.random() * 400;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        positions[i3] = r * Math.sin(phi) * Math.cos(theta);
        positions[i3+1] = r * Math.sin(phi) * Math.sin(theta);
        positions[i3+2] = r * Math.cos(phi);
      }
      starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7, sizeAttenuation: true });
      scene.add(new THREE.Points(starGeometry, starMaterial));
    })();

    // Interaction state (custom controls)
    let isPointerDown = false;
    let lastX = 0, lastY = 0;
    let targetRotX = 0, targetRotY = 0; // target rotations for smoothing
    const rotSmoothing = 0.12;
    let autoRotate = false;

    // initial tilt for nicer view
    earthMesh.rotation.x = 0.4;
    earthMesh.rotation.y = 0.4;
    cloudMesh.rotation.x = 0.4;

    // Pointer handlers on canvas
    renderer.domElement.addEventListener('pointerdown', (e) => {
      isPointerDown = true;
      lastX = e.clientX;
      lastY = e.clientY;
      renderer.domElement.setPointerCapture(e.pointerId);
    });
    renderer.domElement.addEventListener('pointermove', (e) => {
      if (!isPointerDown) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      // horizontal drag => rotate around Y
      targetRotY += dx * 0.005;
      // vertical drag => rotate around X (limited)
      targetRotX += dy * 0.005;
      targetRotX = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, targetRotX));
    });
    renderer.domElement.addEventListener('pointerup', (e) => {
      isPointerDown = false;
      try { renderer.domElement.releasePointerCapture(e.pointerId); } catch {}
    });
    renderer.domElement.addEventListener('pointercancel', () => { isPointerDown = false; });

    // Wheel zoom
    renderer.domElement.addEventListener('wheel', (e) => {
      e.preventDefault();
      cameraDistance += e.deltaY * 0.01;
      cameraDistance = Math.min(maxDistance, Math.max(minDistance, cameraDistance));
    }, { passive: false });

    // Touch pinch support (simple)
    let lastDistance = null;
    renderer.domElement.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastDistance = Math.hypot(dx, dy);
      }
    }, { passive: true });
    renderer.domElement.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2 && lastDistance !== null) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.hypot(dx, dy);
        const diff = lastDistance - dist;
        cameraDistance += diff * 0.01;
        cameraDistance = Math.min(maxDistance, Math.max(minDistance, cameraDistance));
        lastDistance = dist;
      }
    }, { passive: true });
    renderer.domElement.addEventListener('touchend', (e) => { if (e.touches.length < 2) lastDistance = null; }, { passive: true });

    // Buttons
    document.getElementById('leftBtn').addEventListener('click', () => targetRotY -= 0.35);
    document.getElementById('rightBtn').addEventListener('click', () => targetRotY += 0.35);
    document.getElementById('upBtn').addEventListener('click', () => targetRotX -= 0.25);
    document.getElementById('downBtn').addEventListener('click', () => targetRotX += 0.25);
    document.getElementById('zoomInBtn').addEventListener('click', () => { cameraDistance = Math.max(minDistance, cameraDistance - 0.9); });
    document.getElementById('zoomOutBtn').addEventListener('click', () => { cameraDistance = Math.min(maxDistance, cameraDistance + 0.9); });
    document.getElementById('autoRotateBtn').addEventListener('click', () => {
      autoRotate = !autoRotate;
      document.getElementById('autoRotateBtn').textContent = autoRotate ? 'Auto Rotate: ON' : 'Toggle Auto Rotate';
    });
    document.getElementById('resetBtn').addEventListener('click', () => {
      targetRotX = 0.4; targetRotY = 0.4;
      cameraDistance = 6;
      autoRotate = false;
      document.getElementById('autoRotateBtn').textContent = 'Toggle Auto Rotate';
    });

    // Animation loop
    const clock = new THREE.Clock();
    function animate() {
      const dt = clock.getDelta();

      // subtle natural spin for earth & clouds
      earthMesh.rotation.y += 0.02 * dt * 60 * 0.05;
      cloudMesh.rotation.y += 0.025 * dt * 60 * 0.06;

      if (autoRotate) {
        targetRotY += 0.0018 * dt * 60;
      }

      // smooth lerp toward target rotation
      earthGroup.rotation.x += (targetRotX - earthGroup.rotation.x) * rotSmoothing;
      earthGroup.rotation.y += (targetRotY - earthGroup.rotation.y) * rotSmoothing;

      // update camera position from cameraDistance (camera looks at origin)
      camera.position.set(0, 0, cameraDistance);
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // set initial targets
    targetRotX = earthGroup.rotation.x;
    targetRotY = earthGroup.rotation.y;
  </script>
</body>
</html>